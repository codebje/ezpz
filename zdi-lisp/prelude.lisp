;;;
(defun hexb (x) (format t "~2,'0x" x))

(defun in0 (port)
  (zdi-exec #xed #x08 port)
  (logand #xff (zdi-rw-read #x01)))

(defun out0 (port val)
  (zdi-exec #x3e val)
  (zdi-exec #xed #x39 port))

(defun zdi-break () (zdi! #x10 #x98))
(defun zdi-cont () (zdi! #x10 #x18))

(defun zdi-exec (op1 &optional op2 op3 op4 op5)
  (if op5 (zdi! #x21 op5) ())
  (if op4 (zdi! #x22 op4) ())
  (if op3 (zdi! #x23 op3) ())
  (if op2 (zdi! #x24 op2) ())
  (zdi! #x25 op1))

(defun zdi-rw-read (var)
  (when (>= 7 var 0)
    (zdi! #x16 var)
    (logior (ash (zdi? #x12) 16)
            (ash (zdi? #x11) 8)
            (zdi? #x10))))

(defun zdi-status ()
  (let ((stat (zdi? #x03))
        (bus (zdi? #x17)))
    (format t "ZDI_ACTIVE=~3a  HALT_SLP=~3a  ADL=~3a  MADL=~3a  EIF=~3a  ZDI_BUSACK=~3a  ZDI_BUS_STAT=~a"
            (logbitp 7 stat)
            (logbitp 5 stat)
            (logbitp 4 stat)
            (logbitp 3 stat)
            (logbitp 2 stat)
            (logbitp 7 bus)
            (logbitp 6 bus))))

(defun zdi-reg ()
  (format t "MFA=~6,'0x BC=~6,'0x DE=~6,'0x HL=~6,'0x IX=~6,'0x IY=~6,'0x SP=~6,'0x PC=~6,'0x    "
          (zdi-rw-read #x00)
          (zdi-rw-read #x01)
          (zdi-rw-read #x02)
          (zdi-rw-read #x03)
          (zdi-rw-read #x04)
          (zdi-rw-read #x05)
          (zdi-rw-read #x06)
          (zdi-rw-read #x07)))

(defun zdi-read-pcmem ()
  (zdi! #x16 #x0b)
  (zdi? #x10))

(defun zdi-instr ()
  (let ((pc (zdi-rw-read 7))
        (op1 (zdi-read-pcmem))
        (op2 (zdi-read-pcmem))
        (op3 (zdi-read-pcmem))
        (op4 (zdi-read-pcmem))
        (op5 (zdi-read-pcmem)))
    (format t "~2,'0x ~2,'0x ~2,'0x ~2,'0x ~2,'0x~%"
            op1 op2 op3 op4 op5)
    (zdi! #x13 (logand pc #xff))
    (zdi! #x14 (logand (ash pc -8) #xff))
    (zdi! #x15 (logand (ash pc -16) #xff))
    (zdi! #x16 #x87)
    (list pc op1 op2 op3 op4 op5)))

(defun reset ()
  (zdi! #x13 0)
  (zdi! #x14 0)
  (zdi! #x15 0)
  (zdi! #x16 #x87))

(defun step ()
  (zdi! #x10 #x99)
  (zdi-reg)
  (zdi-instr))

(defun brk (addr)
  (zdi! #x00 (logand addr #xff))
  (zdi! #x01 (logand (ash addr -8) #xff))
  (zdi! #x02 (logand (ash addr -16) #xff)))

(defun until (addr)
  (brk addr)
  (zdi-cont)
  (delay 100)
  (zdi-reg)
  (zdi-instr))

(defun skip (c)
  (let* ((pc (zdi-rw-read 7))
         (tgt (+ pc c)))
    (until tgt)))

(defun more ()
  (loop
    (let ((is (step)))
      (case (cadr is)
        (#xc4 (return))
        (#xcc (return))
        (#xcd (return))
        (#xd4 (return))
        (#xdc (return))
        (#xe4 (return))
        (#xec (return))
        (#xf4 (return))
        (#xfc (return))
        (#xc0 (return))
        (#xc8 (return))
        (#xd0 (return))
        (#xd8 (return))
        (#xe0 (return))
        (#xe8 (return))
        (#xf0 (return))
        (#xf8 (return))
        (#xc9 (return))))))

(defun mem (addr)
  (let ((pc (zdi-rw-read 7)))
    (zdi! #x13 (logand #xff addr))
    (zdi! #x14 (logand #xff (ash addr -8)))
    (zdi! #x15 (logand #xff (ash addr -16)))
    (zdi! #x16 #x87)
    (dotimes (x 16)
      (zdi! #x16 #x0b)
      (hexb (zdi? #x10)))
    (zdi! #x13 (logand #xff pc))
    (zdi! #x14 (logand #xff (ash pc -8)))
    (zdi! #x15 (logand #xff (ash pc -16)))
    (zdi! #x16 #x87)))


(defun watch (&optional count)
    (dotimes (x (if count count 10)) (zdi-status) (format t "~%") (delay 1000)))
